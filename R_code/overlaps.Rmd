# Brian Palmer

```{r}
library(Biostrings)
library(stringr)
library(dada2)
library(msa)
load(file.path("/home/bpalmer/Documents/MAD4HATTER_example_data/results/dada2_overlaps.RData"))
amplicon_info <- read.csv("vX_amplicon_info/v4_amplicon_info.tsv", sep = "\t")
```

```{r, include = FALSE}

amplicon_info$amplicon
names(mergers)

mergers[[495]]$sequence <- paste0(dadaFs[[495]]$sequence, "NNNNNNNNNN",
    Biostrings::reverseComplement(
        Biostrings::DNAString(dadaRs[[495]]$sequence)) %>%
            as.character())

mergers[[495]]
```


## Just keep the forward reads

This was proprosed by the author for someone who had 600 bp amplicons with 200 bp reads. https://github.com/benjjneb/dada2/issues/790. 
The downside is this obviously causes loss of information.

```r
seqtab <- gsub("N{10}[ACGT]+", "", getSequences(seqtab))
```

## Possibly could use amplicons from replicates or other samples to determine similarity

```{r}
v <- vector(length = length(mergers))
for (idx in seq_along(mergers)) {
    v[idx] <- nchar(mergers[[idx]]$sequence) > 0 &&
        isTRUE(str_detect(mergers[[idx]]$sequence, "NNNNNNNNNN"))
}

merged_non_overlappers <- mergers[v]

aln_results <- list()
if (length(merged_non_overlappers) > 0) {

    # get the substitution scores given a paremterized error probability
    subscores <- errorSubstitutionMatrices(
        errorProbability = 0.1) # parameterize this

    submat <- matrix(subscores[, , "0"], 4, 4)
    diag(submat) <- subscores[, , "1"]
    dimnames(submat) <- list(DNA_ALPHABET[1:4], DNA_ALPHABET[1:4])

    for (merged_non_overlap in merged_non_overlappers) {

        best_score <- -Inf
        best_alignment <- NULL

        # get the starting sequence
        starting_sequence_name <- names(merged_non_overlap)
        starting_sequence <- DNAString(merged_non_overlappers[[
            starting_sequence_name]]$sequence)

        # get the amplicon name from concatenated sample-amplicon name
        amplicon_name <- sub(
            "_PARAV3.*", "", names(merged_non_overlap)) # parameterize this

        # get all amplicons by name across samples
        amplicons_across <- str_detect(
            names(mergers), amplicon_name)

        for (amplicon in mergers[amplicons_across]) {

            # make sure were not comparing against ourselves
            if (!identical(names(amplicon), names(merged_non_overlap))) {
                # Fit a pairwise comparison
                compare_sequence <- DNAString(
                    mergers[[names(amplicon)]]$sequence)

                score <- pairwiseAlignment(starting_sequence, compare_sequence,
                    substitutionMatrix = subscores, scoreOnly = TRUE)

                if (score > best_score) {
                    best_alignment <- amplicon
                    best_score <- score
                }
            }
        }

        aln_results <- c(aln_results, list(
            starting_sequence_name = starting_sequence_name,
            best_alignment = best_alignment,
            best_score = best_score)
        )
    }
}

```


## A more painful approach reverting to forward and reverse reads.

I'm least confident in this answer.

```{r}
vr <- as.vector(rep(Inf, length(mergers)), mode = "numeric")
vf <- as.vector(rep(Inf, length(mergers)), mode = "numeric")

alignment <- function(fn, x, y) {
    return(fn(x, y))
}
non_overlapping <- mergers[[name]]$sequence

for (i in seq_along(mergers)) {
    name <- names(mergers[i])
    merger_sequence <- mergers[[name]]$sequence
    if (nchar(merger_sequence) > 0 &&
        isTRUE(str_detect(merger_sequence, "NNNNNNNNNN"))) {
            split_merged <- unlist(str_split(merger_sequence, "NNNNNNNNNN"))
            vf[i] <- alignment(adist, split_merged[1], dadaFs[[name]]$sequence)
            vr[i] <- alignment(adist, split_merged[2],
                Biostrings::reverseComplement(
                    Biostrings::DNAString(dadaRs[[name]]$sequence)) %>%
                        as.character())
    }
}

```


```{r}

v <- vector(mode = "logical", length = length(mergers))
for (i in seq_along(mergers)) {
    name <- names(mergers[i])
    if (nchar(mergers[[name]]$sequence) > 0)
        v[i] <- str_detect(mergers[[name]]$sequence, "NNNNNNNNNN")
}

mergers_with_ns <- mergers[v]
s4_dna_strings <- list()
for (i in seq_along(mergers_with_ns)) {
    name <- names(mergers[i])
    s4_dna_strings <- c(s4_dna_strings,
        list(maskMotif(DNAString(mergers_with_ns[[name]]$sequence),
            "NNNNNNNNNN")))
}

if (length(s4_dna_strings) > 0) {
    aln <- msa(s4_dna_strings, method = "Muscle", type = "dna")
    toString(unmasked(aln))
}


```



```{r}
x1 <- "TTCAAAATG"
x2 <- "TTTCAAAAAG"
x3 <- "TTCAAAAAG"

l <- c(x1, x2, x3)
x <- msa(l, method = "Muscle", type = "dna")

n <- nucleotideSubstitutionMatrix(match = 1, mismatch = 0, baseOnly = TRUE, type = "DNA")
q <- qualitySubstitutionMatrices(fuzzyMatch = c(0, 1), alphabetLength = 4L, qualityClass = "PhredQuality", bitScale = 1)
msaConsensusSequence(x)
msaConservationScore(q, n)
maskMotif(BString("AbcbbcbEE"), "bcb")

```
